using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Svelonia.Gen;

[Generator]
public class BindingGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var compilationProvider = context.CompilationProvider;
        context.RegisterSourceOutput(compilationProvider, Execute);
    }

    private void Execute(SourceProductionContext context, Compilation compilation)
    {
        var assemblyName = compilation.AssemblyName?.Replace(".", "_").Replace(" ", "") ?? "Unknown";
        var sb = new StringBuilder();

        // Header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// GENERATOR_VERSION: 2.1_AOT_READY");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS8620, CS8604, CS8619");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Reactive.Linq;");
        sb.AppendLine("using Avalonia.Controls;");
        sb.AppendLine("using Avalonia.Controls.Primitives;");
        sb.AppendLine("using Avalonia.Layout;");
        sb.AppendLine("using Avalonia.Media;");
        sb.AppendLine("using Avalonia.Data;");
        sb.AppendLine("using Svelonia.Core;");
        sb.AppendLine("using Svelonia.Fluent;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine();
        sb.AppendLine("namespace Svelonia.Fluent");
        sb.AppendLine("{");

        // 1. Generate Static/Manual Helpers in a separate class
        GenerateManualHelpers(sb, assemblyName);

        // 2. Discover Types to Generate
        var typesToGenerate = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        // A. Scan [GenerateFluentExtensionsFor] Attributes
        var attributes = compilation.Assembly.GetAttributes();
        var attrType = compilation.GetTypeByMetadataName("Svelonia.Fluent.GenerateFluentExtensionsForAttribute");

        if (attrType != null)
        {
            foreach (var attr in attributes)
            {
                if (SymbolEqualityComparer.Default.Equals(attr.AttributeClass, attrType))
                {
                    if (attr.ConstructorArguments.Length > 0 && attr.ConstructorArguments[0].Value is INamedTypeSymbol targetType)
                    {
                        if (ShouldGenerate(targetType)) typesToGenerate.Add(targetType);
                        bool scanNs = false;
                        if (attr.ConstructorArguments.Length > 1 && attr.ConstructorArguments[1].Value is bool b) scanNs = b;
                        if (scanNs && targetType.ContainingNamespace != null)
                        {
                            CollectTypes(targetType.ContainingNamespace, typesToGenerate);
                        }
                    }
                }
            }
        }

        // B. Default Avalonia Namespaces
        var namespacesToScan = new[] {
            "Avalonia.Controls",
            "Avalonia.Controls.Primitives",
            "Avalonia.Layout",
            "Avalonia.Input"
        };

        foreach (var nsName in namespacesToScan)
        {
            var ns = compilation.GetNamespace(nsName);
            if (ns != null) CollectTypes(ns, typesToGenerate);
        }

        var rootNs = compilation.GetNamespace("Avalonia");
        if (rootNs != null)
        {
            var types = new[] { "Visual", "StyledElement", "AvaloniaObject" };
            foreach (var t in types)
            {
                var sym = rootNs.GetTypeMembers(t).FirstOrDefault();
                if (sym != null && ShouldGenerate(sym)) typesToGenerate.Add(sym);
            }
        }

        var layoutable = compilation.GetTypeByMetadataName("Avalonia.Layout.Layoutable");
        if (layoutable != null && ShouldGenerate(layoutable)) typesToGenerate.Add(layoutable);

        CollectTypes(compilation.Assembly.GlobalNamespace, typesToGenerate);

        // 3. Generate Extensions for each Type
        foreach (var type in typesToGenerate)
        {
            GenerateExtensionsForType(sb, type, assemblyName);
        }

        sb.AppendLine("}");

        context.AddSource("FluentExtensions.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private void CollectTypes(INamespaceSymbol ns, HashSet<INamedTypeSymbol> collected)
    {
        foreach (var member in ns.GetMembers())
        {
            if (member is INamespaceSymbol childNs) CollectTypes(childNs, collected);
            else if (member is INamedTypeSymbol type)
            {
                if (ShouldGenerate(type)) collected.Add(type);
            }
        }
    }

    private bool ShouldGenerate(INamedTypeSymbol type)
    {
        if (type.IsStatic) return false;
        if (type.DeclaredAccessibility != Accessibility.Public) return false;
        if (type.TypeKind != TypeKind.Class) return false;
        if (!InheritsFrom(type, "AvaloniaObject")) return false;
        if (type.Name.StartsWith("<")) return false;
        if (type.IsGenericType) return false;
        if (type.Name == "PopupRoot" || type.Name == "CalendarItem") return false;
        return true;
    }

    private bool InheritsFrom(INamedTypeSymbol symbol, string baseName)
    {
        var baseType = symbol.BaseType;
        while (baseType != null)
        {
            if (baseType.Name == baseName) return true;
            baseType = baseType.BaseType;
        }
        return false;
    }

    private void GenerateManualHelpers(StringBuilder sb, string assemblyName)
    {
        sb.AppendLine($"    internal static class FluentHelpers_{assemblyName}");
        sb.AppendLine("    {");

        // Universal OnClick
        sb.AppendLine(@"
        public static T OnClick<T>(this T control, Action action) where T : Avalonia.Controls.Control
        {
            if (control is Avalonia.Controls.Button btn) btn.Click += (s, e) => action();
            else control.PointerPressed += (s, e) => action();
            return control;
        }

        public static T OnClick<T>(this T control, Action<Avalonia.Interactivity.RoutedEventArgs> action) where T : Avalonia.Controls.Control
        {
            if (control is Avalonia.Controls.Button btn) btn.Click += (s, e) => action(e);
            else control.PointerPressed += (s, e) => action(new Avalonia.Interactivity.RoutedEventArgs());
            return control;
        }
        ");

        // SetMargin
        sb.AppendLine(@"
        public static T SetMargin<T>(this T control, double uniform) where T : Avalonia.Layout.Layoutable
        {
            control.Margin = new Avalonia.Thickness(uniform);
            return control;
        }
        public static T SetMargin<T>(this T control, double horizontal, double vertical) where T : Avalonia.Layout.Layoutable
        {
            control.Margin = new Avalonia.Thickness(horizontal, vertical);
            return control;
        }
        public static T SetMargin<T>(this T control, double left, double top, double right, double bottom) where T : Avalonia.Layout.Layoutable
        {
            control.Margin = new Avalonia.Thickness(left, top, right, bottom);
            return control;
        }
        ");

        // SetBorderThickness
        sb.AppendLine(@"
        public static T SetBorderThickness<T>(this T control, double uniform) where T : Avalonia.Controls.Border
        {
            control.BorderThickness = new Avalonia.Thickness(uniform);
            return control;
        }
        public static T SetBorderThickness<T>(this T control, double horizontal, double vertical) where T : Avalonia.Controls.Border
        {
            control.BorderThickness = new Avalonia.Thickness(horizontal, vertical);
            return control;
        }
        public static T SetBorderThickness<T>(this T control, double left, double top, double right, double bottom) where T : Avalonia.Controls.Border
        {
            control.BorderThickness = new Avalonia.Thickness(left, top, right, bottom);
            return control;
        }
        ");

        // SetCornerRadius
        sb.AppendLine(@"
        public static T SetCornerRadius<T>(this T control, double uniform) where T : Avalonia.Controls.Border
        {
            control.CornerRadius = new Avalonia.CornerRadius(uniform);
            return control;
        }
        ");

        // Grid
        sb.AppendLine(@"
        public static T SetCols<T>(this T control, string definitions) where T : Grid
        {
            control.ColumnDefinitions = ColumnDefinitions.Parse(definitions);
            return control;
        }
        public static T SetRows<T>(this T control, string definitions) where T : Grid
        {
            control.RowDefinitions = RowDefinitions.Parse(definitions);
            return control;
        }
        public static T SetCol<T>(this T control, int value) where T : Control
        {
            Grid.SetColumn(control, value);
            return control;
        }
        public static T SetRow<T>(this T control, int value) where T : Control
        {
            Grid.SetRow(control, value);
            return control;
        }
        public static T SetColSpan<T>(this T control, int value) where T : Control
        {
            Grid.SetColumnSpan(control, value);
            return control;
        }
        public static T SetRowSpan<T>(this T control, int value) where T : Control
        {
            Grid.SetRowSpan(control, value);
            return control;
        }
        public static T SetDock<T>(this T control, Avalonia.Controls.Dock dock) where T : Control
        {
            DockPanel.SetDock(control, dock);
            return control;
        }
        ");

        // Panel Children
        sb.AppendLine(@"
        public static T SetChildren<T>(this T control, params Control[] children) where T : Panel
        {
            foreach (var child in children) child.DetachFromParent();
            control.Children.AddRange(children);
            return control;
        }

        public static T BindChildren<T>(this T control, State<Control> childState) where T : Panel
        {
            Control? lastControl = null;
            void Handler(Control v)
            {
                if (lastControl != null) control.Children.Remove(lastControl);
                lastControl = v;
                if (v != null) { v.DetachFromParent(); control.Children.Add(v); }
            }
            lastControl = childState.Value;
            if (lastControl != null) { lastControl.DetachFromParent(); control.Children.Add(lastControl); }
            if (control is Control c)
            {
                c.AttachedToVisualTree += (s, e) => { childState.OnChange += Handler; };
                c.DetachedFromVisualTree += (s, e) => { childState.OnChange -= Handler; };
                if (c.IsLoaded) childState.OnChange += Handler;
            }
            return control;
        }

        public static T BindChildren<T>(this T control, State<IEnumerable<Control>> childrenState) where T : Panel
        {
            List<Control> lastChildren = new();
            void Handler(IEnumerable<Control> v)
            {
                foreach (var child in lastChildren) control.Children.Remove(child);
                lastChildren = v.ToList();
                foreach (var child in lastChildren) child.DetachFromParent();
                control.Children.AddRange(lastChildren);
            }
            lastChildren = childrenState.Value.ToList();
            foreach (var child in lastChildren) child.DetachFromParent();
            control.Children.AddRange(lastChildren);
            if (control is Control c)
            {
                c.AttachedToVisualTree += (s, e) => { childrenState.OnChange += Handler; };
                c.DetachedFromVisualTree += (s, e) => { childrenState.OnChange -= Handler; };
                if (c.IsLoaded) childrenState.OnChange += Handler;
            }
            return control;
        }
        ");

        sb.AppendLine("    }");

        // Decorator
        sb.AppendLine($"    internal static class FluentHelpers_Decorator_{assemblyName} {{");
        sb.AppendLine(@"
        public static T SetPadding<T>(this T control, double uniform) where T : Avalonia.Controls.Decorator
        {
            control.Padding = new Avalonia.Thickness(uniform);
            return control;
        }
        public static T SetPadding<T>(this T control, double horizontal, double vertical) where T : Avalonia.Controls.Decorator
        {
            control.Padding = new Avalonia.Thickness(horizontal, vertical);
            return control;
        }
        public static T SetPadding<T>(this T control, double left, double top, double right, double bottom) where T : Avalonia.Controls.Decorator
        {
            control.Padding = new Avalonia.Thickness(left, top, right, bottom);
            return control;
        }
        public static T SetChild<T>(this T control, Control child) where T : Decorator
        {
            child.DetachFromParent();
            control.Child = child;
            return control;
        }
        public static T BindChild<T>(this T control, State<Control> childState) where T : Decorator
        {
             void Handler(Control v) { v?.DetachFromParent(); control.Child = v; }
             if (childState.Value != null) childState.Value.DetachFromParent();
             control.Child = childState.Value;
             if(control is Control c) {
                 c.AttachedToVisualTree += (s,e) => { control.Child = childState.Value; childState.OnChange += Handler; };
                 c.DetachedFromVisualTree += (s,e) => { childState.OnChange -= Handler; };
                 if(c.IsLoaded) childState.OnChange += Handler;
             }
             return control;
        }
        ");
        sb.AppendLine("    }");

        // TemplatedControl
        sb.AppendLine($"    internal static class FluentHelpers_TemplatedControl_{assemblyName} {{");
        sb.AppendLine(@"
        public static T SetPadding<T>(this T control, double uniform) where T : Avalonia.Controls.Primitives.TemplatedControl
        {
            control.Padding = new Avalonia.Thickness(uniform);
            return control;
        }
        public static T SetPadding<T>(this T control, double horizontal, double vertical) where T : Avalonia.Controls.Primitives.TemplatedControl
        {
            control.Padding = new Avalonia.Thickness(horizontal, vertical);
            return control;
        }
        public static T SetPadding<T>(this T control, double left, double top, double right, double bottom) where T : Avalonia.Controls.Primitives.TemplatedControl
        {
            control.Padding = new Avalonia.Thickness(left, top, right, bottom);
            return control;
        }
        ");
        sb.AppendLine("    }");
    }

    private void GenerateExtensionsForType(StringBuilder sb, INamedTypeSymbol type, string assemblyName)
    {
        var typeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var safeName = type.ToDisplayString().Replace(".", "_").Replace("<", "").Replace(">", "");
        sb.AppendLine($"    internal static class FluentExtensions_{safeName}_{assemblyName} {{");

        var props = type.GetMembers().OfType<IPropertySymbol>()
            .Where(p => !p.IsStatic && !p.IsReadOnly && !p.IsIndexer && p.DeclaredAccessibility == Accessibility.Public &&
                        p.SetMethod != null && p.SetMethod.DeclaredAccessibility == Accessibility.Public &&
                        SymbolEqualityComparer.Default.Equals(p.ContainingType, type));

        foreach (var prop in props)
        {
            if (prop.GetAttributes().Any(a => a.AttributeClass?.Name == "ObsoleteAttribute")) continue;
            GeneratePropertyExtension(sb, type, typeName, prop);
        }
        sb.AppendLine("    }");
    }

    private void GeneratePropertyExtension(StringBuilder sb, INamedTypeSymbol type, string typeName, IPropertySymbol prop)
    {
        var propName = prop.Name;
        var propType = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var avaloniaPropField = prop.ContainingType.GetMembers($"{propName}Property").FirstOrDefault();
        bool isAvaloniaProp = avaloniaPropField != null && avaloniaPropField.IsStatic;

        string paramType = prop.Type.IsValueType && prop.Type.OriginalDefinition.SpecialType != SpecialType.System_Nullable_T ? propType + "?" : (propType.EndsWith("?") ? propType : propType + "?");

        if ((propName == "Child" && typeName.EndsWith("Decorator")) ||
            (propName == "Children" && typeName.EndsWith("Panel")) ||
            (propName == "ColumnDefinitions" && typeName.EndsWith("Grid")) ||
            (propName == "RowDefinitions" && typeName.EndsWith("Grid")) ||
            (propName == "Text" && typeName.Contains("TextBox")) ||
            (propName == "IsChecked" && typeName.Contains("ToggleButton")) ||
            (propName == "Value" && typeName.Contains("RangeBase"))) return;

        // SetX
        sb.AppendLine($"        public static T Set{propName}<T>(this T control, {propType} value, {paramType} hover = default, {paramType} pressed = default) where T : {typeName}");
        sb.AppendLine("        {");
        sb.AppendLine("            if (hover == null && pressed == null) {");
        sb.AppendLine($"                if ((object?)value is Avalonia.Controls.Control ctrl) ctrl.DetachFromParent();");
        sb.AppendLine($"                control.{propName} = value;");
        sb.AppendLine("            } else {");
        if (isAvaloniaProp && InheritsFrom(type, "Control")) sb.AppendLine($"                Svelonia.Fluent.ControlStyleExtensions.SetStateProperty(control, {typeName}.{propName}Property, value, hover, pressed);");
        else
        {
            sb.AppendLine($"                if ((object?)value is Avalonia.Controls.Control ctrl) ctrl.DetachFromParent();");
            sb.AppendLine($"                control.{propName} = value;");
        }
        sb.AppendLine("            }");
        sb.AppendLine("            return control;");
        sb.AppendLine("        }");

        // BindX
        if (isAvaloniaProp)
        {
            sb.AppendLine($"        public static T Bind{propName}<T>(this T control, Avalonia.Markup.Xaml.MarkupExtensions.DynamicResourceExtension resource) where T : {typeName}");
            sb.AppendLine($"        {{ control.Bind({typeName}.{propName}Property, resource); return control; }}");
        }

        if (propName == "Content" && typeName.Contains("ContentControl"))
        {
            sb.AppendLine($"        public static T Bind{propName}<T, TState>(this T control, State<TState> state) where T : {typeName}");
            sb.AppendLine("        {");
            sb.AppendLine($"            if (state is State<string> s) Svelonia.Fluent.StyleExtensions.BindContent(control, s);");
            sb.AppendLine($"            else {{ var observable = state.Select(x => {{ if ((object?)x is Avalonia.Controls.Control ctrl) ctrl.DetachFromParent(); return (object?)x; }}); control.Bind({typeName}.{propName}Property, observable); }}");
            sb.AppendLine("            return control;");
            sb.AppendLine("        }");
        }
        else
        {
            sb.AppendLine($"        public static T Bind{propName}<T>(this T control, State<{propType}> state) where T : {typeName}");
            sb.AppendLine("        {");
            if (isAvaloniaProp) sb.AppendLine($"            control.Bind({typeName}.{propName}Property, state.Select(x => SveConverter.Convert({typeName}.{propName}Property, x)));");
            else
            {
                sb.AppendLine($"            void Handler({propType} val) => control.{propName} = val;");
                sb.AppendLine($"            control.{propName} = state.Value;");
                sb.AppendLine($"            if(control is Avalonia.Controls.Control c) {{");
                sb.AppendLine($"                c.AttachedToVisualTree += (s, e) => {{ control.{propName} = state.Value; state.OnChange += Handler; }};");
                sb.AppendLine($"                c.DetachedFromVisualTree += (s, e) => {{ state.OnChange -= Handler; }};");
                sb.AppendLine($"                if (c.IsLoaded) state.OnChange += Handler;");
                sb.AppendLine($"            }}");
            }
            sb.AppendLine("            return control;");
            sb.AppendLine("        }");
        }
    }
}

public static class CompilationExtensions
{
    public static INamespaceSymbol? GetNamespace(this Compilation compilation, string name)
    {
        var parts = name.Split('.');
        var current = compilation.GlobalNamespace;
        foreach (var part in parts)
        {
            var next = current.GetMembers(part).OfType<INamespaceSymbol>().FirstOrDefault();
            if (next == null) return null;
            current = next;
        }
        return current;
    }
}
