using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Svelonia.Gen;

[Generator]
public class BindingGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var compilationProvider = context.CompilationProvider;
        context.RegisterSourceOutput(compilationProvider, Execute);
    }

    private void Execute(SourceProductionContext context, Compilation compilation)
    {
        var assemblyName = compilation.AssemblyName?.Replace(".", "_").Replace(" ", "") ?? "Unknown";
        var sb = new StringBuilder();

        // Header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using Avalonia.Controls;");
        sb.AppendLine("using Avalonia.Controls.Primitives;");
        sb.AppendLine("using Avalonia.Layout;");
        sb.AppendLine("using Avalonia.Media;");
        sb.AppendLine("using Avalonia.Data;");
        sb.AppendLine("using Svelonia.Core;");
        sb.AppendLine("using Svelonia.Fluent;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine("namespace Svelonia.Generated");
        sb.AppendLine("{");

        // 1. Generate Static/Manual Helpers in a separate class
        GenerateManualHelpers(sb, assemblyName);

        // 2. Discover Types to Generate
        // We want types from specific Avalonia namespaces + Current Project (Assembly)
        var typesToGenerate = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        // A. Scan [GenerateFluentExtensionsFor] Attributes
        var attributes = compilation.Assembly.GetAttributes();
        var attrType = compilation.GetTypeByMetadataName("Svelonia.Fluent.GenerateFluentExtensionsForAttribute");

        if (attrType != null)
        {
            foreach (var attr in attributes)
            {
                if (SymbolEqualityComparer.Default.Equals(attr.AttributeClass, attrType))
                {
                    if (attr.ConstructorArguments.Length > 0 && attr.ConstructorArguments[0].Value is INamedTypeSymbol targetType)
                    {
                        if (ShouldGenerate(targetType)) typesToGenerate.Add(targetType);

                        // Check ScanNamespace flag
                        bool scanNs = false;
                        if (attr.ConstructorArguments.Length > 1 && attr.ConstructorArguments[1].Value is bool b) scanNs = b;

                        if (scanNs && targetType.ContainingNamespace != null)
                        {
                            CollectTypes(targetType.ContainingNamespace, typesToGenerate);
                        }
                    }
                }
            }
        }

        // B. Default Avalonia Namespaces
        var namespacesToScan = new[] {
            "Avalonia.Controls",
            "Avalonia.Controls.Primitives",
            "Avalonia.Layout",
            "Avalonia.Input"
        };

        foreach (var nsName in namespacesToScan)
        {
            var ns = compilation.GetNamespace(nsName);
            if (ns != null) CollectTypes(ns, typesToGenerate);
        }

        // Also scan Avalonia root for Visual, StyledElement, etc.
        var rootNs = compilation.GetNamespace("Avalonia");
        if (rootNs != null)
        {
            // Scan specific types in Avalonia root
            var types = new[] { "Visual", "StyledElement", "AvaloniaObject" };
            foreach (var t in types)
            {
                var sym = rootNs.GetTypeMembers(t).FirstOrDefault();
                if (sym != null && ShouldGenerate(sym)) typesToGenerate.Add(sym);
            }
        }

        // Explicitly ensure Layoutable is present (sometimes namespace scan is tricky)
        var layoutable = compilation.GetTypeByMetadataName("Avalonia.Layout.Layoutable");
        if (layoutable != null && ShouldGenerate(layoutable)) typesToGenerate.Add(layoutable);

        // Only scan current ASSEMBLY for user controls
        CollectTypes(compilation.Assembly.GlobalNamespace, typesToGenerate);

        // 3. Generate Extensions for each Type in its own class to avoid collisions
        foreach (var type in typesToGenerate)
        {
            GenerateExtensionsForType(sb, type, assemblyName);
        }

        sb.AppendLine("}");

        context.AddSource("FluentExtensions.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private void CollectTypes(INamespaceSymbol ns, HashSet<INamedTypeSymbol> collected)
    {
        foreach (var member in ns.GetMembers())
        {
            if (member is INamespaceSymbol childNs)
            {
                CollectTypes(childNs, collected);
            }
            else if (member is INamedTypeSymbol type)
            {
                if (ShouldGenerate(type))
                {
                    collected.Add(type);
                }
            }
        }
    }

    private bool ShouldGenerate(INamedTypeSymbol type)
    {
        // Allow abstract classes (e.g. Layoutable) because they define properties we want extensions for.
        if (type.IsStatic) return false;
        if (type.DeclaredAccessibility != Accessibility.Public) return false;
        if (type.TypeKind != TypeKind.Class) return false;

        // Must inherit from AvaloniaObject
        if (!InheritsFrom(type, "AvaloniaObject")) return false;

        if (type.Name.StartsWith("<")) return false;
        if (type.IsGenericType) return false; // Skip generics for simplicity

        // Exclude specific types that cause constraint issues (likely internal/protected or infrastructure)
        if (type.Name == "PopupRoot" || type.Name == "CalendarItem") return false;

        return true;
    }

    private bool InheritsFrom(INamedTypeSymbol symbol, string baseName)
    {
        var baseType = symbol.BaseType;
        while (baseType != null)
        {
            if (baseType.Name == baseName) return true;
            baseType = baseType.BaseType;
        }
        return false;
    }

    private void GenerateManualHelpers(StringBuilder sb, string assemblyName)
    {
        sb.AppendLine($"    internal static class FluentHelpers_{assemblyName}");
        sb.AppendLine("    {");

        // Button Events
        sb.AppendLine(@"
        public static T OnClick<T>(this T control, Action<Avalonia.Interactivity.RoutedEventArgs> action) where T : Avalonia.Controls.Button
        {
            control.Click += (s, e) => action(e);
            return control;
        }
        ");

        // Thickness Helpers (Margin - Layoutable)
        sb.AppendLine(@"
        public static T Margin<T>(this T control, double uniform) where T : Avalonia.Layout.Layoutable
        {
            control.Margin = new Avalonia.Thickness(uniform);
            return control;
        }
        public static T Margin<T>(this T control, double horizontal, double vertical) where T : Avalonia.Layout.Layoutable
        {
            control.Margin = new Avalonia.Thickness(horizontal, vertical);
            return control;
        }
        public static T Margin<T>(this T control, double left, double top, double right, double bottom) where T : Avalonia.Layout.Layoutable
        {
            control.Margin = new Avalonia.Thickness(left, top, right, bottom);
            return control;
        }
        ");

        // BorderThickness (Border)
        sb.AppendLine(@"
        public static T BorderThickness<T>(this T control, double uniform) where T : Avalonia.Controls.Border
        {
            control.BorderThickness = new Avalonia.Thickness(uniform);
            return control;
        }
        public static T BorderThickness<T>(this T control, double horizontal, double vertical) where T : Avalonia.Controls.Border
        {
            control.BorderThickness = new Avalonia.Thickness(horizontal, vertical);
            return control;
        }
        public static T BorderThickness<T>(this T control, double left, double top, double right, double bottom) where T : Avalonia.Controls.Border
        {
            control.BorderThickness = new Avalonia.Thickness(left, top, right, bottom);
            return control;
        }
        ");

        // CornerRadius (Border)
        sb.AppendLine(@"
        public static T CornerRadius<T>(this T control, double uniform) where T : Avalonia.Controls.Border
        {
            control.CornerRadius = new Avalonia.CornerRadius(uniform);
            return control;
        }
        ");

        // Grid Helpers
        sb.AppendLine(@"
        public static T Cols<T>(this T control, string definitions) where T : Grid
        {
            control.ColumnDefinitions = ColumnDefinitions.Parse(definitions);
            return control;
        }
        public static T Rows<T>(this T control, string definitions) where T : Grid
        {
            control.RowDefinitions = RowDefinitions.Parse(definitions);
            return control;
        }
        
        // Attached Properties
        public static T Col<T>(this T control, int value) where T : Control
        {
            Grid.SetColumn(control, value);
            return control;
        }
        public static T Row<T>(this T control, int value) where T : Control
        {
            Grid.SetRow(control, value);
            return control;
        }
        public static T ColSpan<T>(this T control, int value) where T : Control
        {
            Grid.SetColumnSpan(control, value);
            return control;
        }
        public static T RowSpan<T>(this T control, int value) where T : Control
        {
            Grid.SetRowSpan(control, value);
            return control;
        }
        public static T Dock<T>(this T control, Avalonia.Controls.Dock dock) where T : Control
        {
            DockPanel.SetDock(control, dock);
            return control;
        }

        // Panel Children
        public static T Children<T>(this T control, params Control[] children) where T : Panel
        {
            control.Children.AddRange(children);
            return control;
        }
        ");
        sb.AppendLine("    }"); // End FluentHelpers

        // Separate Class for Decorator Helpers (Padding)
        sb.AppendLine($"    internal static class FluentHelpers_Decorator_{assemblyName}");
        sb.AppendLine("    {");
        sb.AppendLine(@"
        public static T Padding<T>(this T control, double uniform) where T : Avalonia.Controls.Decorator
        {
            control.Padding = new Avalonia.Thickness(uniform);
            return control;
        }
        public static T Padding<T>(this T control, double horizontal, double vertical) where T : Avalonia.Controls.Decorator
        {
            control.Padding = new Avalonia.Thickness(horizontal, vertical);
            return control;
        }
        public static T Padding<T>(this T control, double left, double top, double right, double bottom) where T : Avalonia.Controls.Decorator
        {
            control.Padding = new Avalonia.Thickness(left, top, right, bottom);
            return control;
        }
        // Child Helper
        public static T Child<T>(this T control, Control child) where T : Decorator
        {
            control.Child = child;
            return control;
        }
        public static T Child<T>(this T control, State<Control> childState) where T : Decorator
        {
             void Handler(Control v) => control.Child = v;
             control.Child = childState.Value;
             if(control is Control c)
             {
                 c.AttachedToVisualTree += (s,e) => { control.Child = childState.Value; childState.OnChange += Handler; };
                 c.DetachedFromVisualTree += (s,e) => { childState.OnChange -= Handler; };
                 if(c.IsLoaded) childState.OnChange += Handler;
             }
             return control;
        }
        ");
        sb.AppendLine("    }");

        // Separate Class for TemplatedControl Helpers (Padding)
        sb.AppendLine($"    internal static class FluentHelpers_TemplatedControl_{assemblyName}");
        sb.AppendLine("    {");
        sb.AppendLine(@"
        public static T Padding<T>(this T control, double uniform) where T : Avalonia.Controls.Primitives.TemplatedControl
        {
            control.Padding = new Avalonia.Thickness(uniform);
            return control;
        }
        public static T Padding<T>(this T control, double horizontal, double vertical) where T : Avalonia.Controls.Primitives.TemplatedControl
        {
            control.Padding = new Avalonia.Thickness(horizontal, vertical);
            return control;
        }
        public static T Padding<T>(this T control, double left, double top, double right, double bottom) where T : Avalonia.Controls.Primitives.TemplatedControl
        {
            control.Padding = new Avalonia.Thickness(left, top, right, bottom);
            return control;
        }
        ");
        sb.AppendLine("    }");
    }

    private void GenerateExtensionsForType(StringBuilder sb, INamedTypeSymbol type, string assemblyName)
    {
        var typeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var safeName = type.ToDisplayString().Replace(".", "_").Replace("<", "").Replace(">", "");

        sb.AppendLine($"    internal static class FluentExtensions_{safeName}_{assemblyName}");
        sb.AppendLine("    {");

        // Get public properties declared IN THIS TYPE ONLY
        var props = type.GetMembers().OfType<IPropertySymbol>()
            .Where(p => !p.IsStatic &&
                        !p.IsReadOnly &&
                        !p.IsIndexer &&
                        p.DeclaredAccessibility == Accessibility.Public &&
                        p.SetMethod != null && p.SetMethod.DeclaredAccessibility == Accessibility.Public && // Ensure setter is public
                        SymbolEqualityComparer.Default.Equals(p.ContainingType, type));

        foreach (var prop in props)
        {
            if (prop.GetAttributes().Any(a => a.AttributeClass?.Name == "ObsoleteAttribute")) continue;
            // FontSize is allowed now
            GeneratePropertyExtension(sb, typeName, prop);
        }

        sb.AppendLine("    }");
    }

    private void GeneratePropertyExtension(StringBuilder sb, string typeName, IPropertySymbol prop)
    {
        var propName = prop.Name;
        var propType = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        // Skip manual helpers
        if ((propName == "Child" && typeName.EndsWith("Decorator")) ||
            (propName == "Children" && typeName.EndsWith("Panel")) ||
            (propName == "ColumnDefinitions" && typeName.EndsWith("Grid")) ||
            (propName == "RowDefinitions" && typeName.EndsWith("Grid")))
        {
            return;
        }

        // Value Setter
        sb.AppendLine($"        public static T {propName}<T>(this T control, {propType} value) where T : {typeName}");
        sb.AppendLine("        {");
        sb.AppendLine($"            control.{propName} = value;");
        sb.AppendLine("            return control;");
        sb.AppendLine("        }");

        // State Setter
        var avaloniaPropField = prop.ContainingType.GetMembers($"{propName}Property").FirstOrDefault();
        bool isAvaloniaProp = avaloniaPropField != null && avaloniaPropField.IsStatic;

        // Special handling for ContentControl.Content to support implicit string conversion via BindContent
        if (propName == "Content" && typeName.Contains("ContentControl"))
        {
            // Generate generic State<TContent> overload that routes to BindContent/Bind
            sb.AppendLine($"        public static T {propName}<T, TState>(this T control, State<TState> state) where T : {typeName}");
            sb.AppendLine("        {");
            sb.AppendLine($"            // Special handling for Content to support string conversion");
            sb.AppendLine($"            if (state is State<string> s)");
            sb.AppendLine($"            {{");
            sb.AppendLine($"                Svelonia.Fluent.Bindings.StyleExtensions.BindContent(control, s);");
            sb.AppendLine($"            }}");
            sb.AppendLine($"            else");
            sb.AppendLine($"            {{");
            sb.AppendLine($"                void Handler(TState val) => control.Content = val;");
            sb.AppendLine($"                control.Content = state.Value;");
            sb.AppendLine($"                if(control is Avalonia.Controls.Control c)");
            sb.AppendLine($"                {{");
            sb.AppendLine($"                    c.AttachedToVisualTree += (s, e) => {{ control.Content = state.Value; state.OnChange += Handler; }};");
            sb.AppendLine($"                    c.DetachedFromVisualTree += (s, e) => {{ state.OnChange -= Handler; }};");
            sb.AppendLine($"                    if (c.IsLoaded) state.OnChange += Handler;");
            sb.AppendLine($"                }}");
            sb.AppendLine($"            }}");
            sb.AppendLine("            return control;");
            sb.AppendLine("        }");
            return;
        }

        sb.AppendLine($"        public static T {propName}<T>(this T control, State<{propType}> state) where T : {typeName}");
        sb.AppendLine("        {");

        if (isAvaloniaProp)
        {
            sb.AppendLine($"            Svelonia.Fluent.Binder.Bind(control, {typeName}.{propName}Property, state);");
        }
        else
        {
            sb.AppendLine($"            void Handler({propType} val) => control.{propName} = val;");
            sb.AppendLine($"            control.{propName} = state.Value;");
            sb.AppendLine("            if(control is Avalonia.Controls.Control c)");
            sb.AppendLine("            {");
            sb.AppendLine($"                c.AttachedToVisualTree += (s, e) => {{ control.{propName} = state.Value; state.OnChange += Handler; }};");
            sb.AppendLine("                c.DetachedFromVisualTree += (s, e) => {{ state.OnChange -= Handler; }};");
            sb.AppendLine("                if (c.IsLoaded) state.OnChange += Handler;");
            sb.AppendLine("            }");
        }

        sb.AppendLine("            return control;");
        sb.AppendLine("        }");
    }
}

public static class CompilationExtensions
{
    public static INamespaceSymbol? GetNamespace(this Compilation compilation, string name)
    {
        var parts = name.Split('.');
        var current = compilation.GlobalNamespace;
        foreach (var part in parts)
        {
            var next = current.GetMembers(part).OfType<INamespaceSymbol>().FirstOrDefault();
            if (next == null) return null;
            current = next;
        }
        return current;
    }
}