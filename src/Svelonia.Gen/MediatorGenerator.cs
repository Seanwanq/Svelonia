using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Svelonia.Gen;

[Generator]
public class MediatorGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => s is ClassDeclarationSyntax,
                transform: (ctx, _) => GetClassSymbol(ctx))
            .Where(m => m != null);

        var compilation = context.CompilationProvider.Combine(provider.Collect());

        context.RegisterSourceOutput(compilation, (spc, source) => Execute(spc, source.Left, source.Right));
    }

    private static INamedTypeSymbol? GetClassSymbol(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
        return symbol as INamedTypeSymbol;
    }

    private void Execute(SourceProductionContext context, Compilation compilation, System.Collections.Immutable.ImmutableArray<INamedTypeSymbol?> classes)
    {
        var handlers = new List<(string RequestType, string ResponseType, string HandlerType)>();

        var requestHandlerInterface = compilation.GetTypeByMetadataName("Svelonia.Data.IRequestHandler`2");

        if (requestHandlerInterface == null) return;

        foreach (var cls in classes)
        {
            if (cls == null || cls.IsAbstract || cls.IsGenericType) continue;

            foreach (var iface in cls.AllInterfaces)
            {
                if (iface.IsGenericType &&
                    SymbolEqualityComparer.Default.Equals(iface.ConstructedFrom, requestHandlerInterface))
                {
                    var requestType = iface.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var responseType = iface.TypeArguments[1].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var handlerType = cls.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    handlers.Add((requestType, responseType, handlerType));
                }
            }
        }

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Svelonia.Data;");
        sb.AppendLine();
        sb.AppendLine("namespace Svelonia.Generated");
        sb.AppendLine("{");
        sb.AppendLine("    internal static class MediatorRegistry");
        sb.AppendLine("    {");
        sb.AppendLine("        public static async Task<object?> Dispatch(IServiceProvider services, object request, CancellationToken token)");
        sb.AppendLine("        {");
        sb.AppendLine("            var type = request.GetType();");
        sb.AppendLine();

        // Generate dispatch logic
        var index = 0;
        foreach (var handler in handlers)
        {
            var ifElse = index == 0 ? "if" : "else if";
            sb.AppendLine($"            {ifElse} (type == typeof({handler.RequestType}))");
            sb.AppendLine("            {");
            sb.AppendLine($"                var handler = services.GetRequiredService<{handler.HandlerType}>();");
            sb.AppendLine($"                return await handler.Handle (({handler.RequestType})request, token);");
            sb.AppendLine("            }");
            index++;
        }

        sb.AppendLine();
                    sb.AppendLine("            throw new InvalidOperationException($\"No handler registered for request type '{type.FullName}'. Generated registry did not find a match.\");");        sb.AppendLine("        }");

        sb.AppendLine("        public static void RegisterHandlers(IServiceCollection services)");
        sb.AppendLine("        {");
        foreach (var h in handlers)
        {
            sb.AppendLine($"            services.AddTransient<{h.HandlerType}>();");
        }
        sb.AppendLine("        }");

        sb.AppendLine("    }");

        // Generate Extension Method for DI
        sb.AppendLine("    internal static class ServiceCollectionExtensionsAot");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Registers Mediator and Handlers using the AOT-safe generated registry.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static IServiceCollection AddSveloniaDataAot(this IServiceCollection services)");
        sb.AppendLine("        {");
        sb.AppendLine("            services.AddSingleton<IMediator, Mediator>();");
        sb.AppendLine("            // Register handlers");
        sb.AppendLine("            MediatorRegistry.RegisterHandlers(services);");
        sb.AppendLine("            // Hook up AOT dispatcher");
        sb.AppendLine("            Mediator.DispatcherDelegate = MediatorRegistry.Dispatch;");
        sb.AppendLine("            return services;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        context.AddSource("MediatorRegistry.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}